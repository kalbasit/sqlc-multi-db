package generator

const generatedFilePrefix = "generated_"

const modelsTemplate = `// Code generated by sqlc-multi-db. DO NOT EDIT.
package {{.PackageName}}

import (
	"database/sql"
)

{{range .Structs}}
type {{.Name}} struct {
{{- range .Fields}}
	{{.Name}} {{.Type}} {{if .Tag}}` + "`" + `{{.Tag}}` + "`" + `{{end}}
{{- end}}
}
{{end}}
`

const querierTemplate = `// Code generated by sqlc-multi-db. DO NOT EDIT.
package {{.PackageName}}

import (
	"context"
	"database/sql"
)

type Querier interface {
{{- range .Methods}}
	{{- range .Docs}}
	{{.}}
	{{- end}}
	{{.Name}}({{joinParamsSignature .Params}}) ({{joinReturns .Returns}})
{{- end}}

	WithTx(tx *sql.Tx) Querier
	DB() *sql.DB
}
`

const errorsTemplate = `// Code generated by sqlc-multi-db. DO NOT EDIT.
package {{.PackageName}}

import "errors"

var (
	// ErrNotFound is returned when a query returns no rows.
	ErrNotFound = errors.New("not found")

	// ErrMismatchedSlices is returned when bulk operations receive slices of different lengths.
	ErrMismatchedSlices = errors.New("mismatched slice lengths")
)
`

const wrapperTemplate = `// Code generated by sqlc-multi-db. DO NOT EDIT.
package {{.PackageName}}

import (
	"context"
	"database/sql"
	"errors"

	"{{.ImportBase}}/{{.Engine.Package}}"
)

// {{.Engine.Name}}Wrapper wraps the {{.Engine.Name}} adapter.
type {{.Engine.Name}}Wrapper struct {
	adapter *{{.Engine.Package}}.Adapter
}

{{range .Methods}}
{{- $method := . -}}
{{- $methodParams := .Params }}
func (w *{{$.Engine.Name}}Wrapper) {{.Name}}({{joinParamsSignature .Params}}) ({{joinReturns .Returns}}) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */
	{{$isAutoLoop := false}}
	{{$singularMethodName := ""}}
	{{- $paramType := "" -}}
	{{- $sliceField := dict "Name" "" -}}
	{{- if and (not $.Engine.IsPostgres) (gt (len .Params) 1) -}}
		{{- $pType := (index .Params 1).Type -}}
		{{- $sInfo := getStruct $pType -}}
		{{- if hasSliceField $sInfo -}}
			{{- if .BulkFor -}}
				{{- $isAutoLoop = true -}}
				{{- $singularMethodName = .BulkFor -}}
				{{- $paramType = $pType -}}
				{{- $sliceField = getSliceField $sInfo -}}
			{{- else if hasSuffix .Name "s" -}}
				{{- $singularMethodName = toSingular .Name -}}
				{{- if ne $singularMethodName .Name -}}
					{{- $singularParamType := printf "%sParams" $singularMethodName -}}
					{{- $sInfoSingular := getStruct $singularParamType -}}
					{{- if ne $sInfoSingular.Name "" -}}
						{{- $isAutoLoop = true -}}
						{{- $paramType = $pType -}}
						{{- $sliceField = getSliceField $sInfo -}}
					{{- end -}}
				{{- end -}}
			{{- end -}}
		{{- end -}}
	{{- end -}}

	{{if $isAutoLoop}}
		{{- $bulkParamType := (index .Params 1).Type -}}
		{{- $bulkStructInfo := getStruct $bulkParamType -}}
		{{- $singularParamType := printf "%sParams" $singularMethodName -}}
		{{- $targetSingularParamType := $singularParamType -}} {{/* Assume same name for now */}}
		{{- $targetStructInfo := getTargetStruct $targetSingularParamType -}}
		{{/* Check for mismatched slice lengths */}}
		{{- range $bulkStructInfo.Fields}}
			{{- if and (isSlice .Type) (ne .Name $sliceField.Name) }}
		if len({{(index $methodParams 1).Name}}.{{.Name}}) != len({{(index $methodParams 1).Name}}.{{$sliceField.Name}}) {
			{{$retType := firstReturnType $method.Returns}}
			return {{if $method.ReturnsSelf}}nil, {{else if not $method.HasValue}}{{else if isSlice $retType}}nil, {{else if isDomainStruct $method.ReturnElem}}{{$method.ReturnElem}}{}, {{else}}{{zeroValue $retType}}, {{end}}ErrMismatchedSlices
		}
			{{- end}}
		{{- end}}
		for i, v := range {{(index .Params 1).Name}}.{{$sliceField.Name}} {
			_ = i
			err := w.adapter.{{$singularMethodName}}({{(index .Params 0).Name}}, {{$.Engine.Package}}.{{$targetSingularParamType}}{
				{{range $targetStructField := $targetStructInfo.Fields}}
					{{/* Find matching field in bulk (source) struct */}}
					{{$sourceField := dict "Name" ""}}
					{{range $bulkStructInfo.Fields}}
						{{if eq .Name $targetStructField.Name}}
							{{$sourceField = .}}
						{{end}}
						{{if and (eq $sourceField.Name "") (eq (toSingular .Name) $targetStructField.Name)}}
							{{$sourceField = .}}
						{{end}}
					{{end}}
					{{if ne $sourceField.Name ""}}
						{{$srcExpr := ""}}
						{{if eq $sourceField.Name $sliceField.Name}}
							{{$srcExpr = "v"}}
						{{else if isSlice $sourceField.Type}}
							{{$srcExpr = printf "%s.%s[i]" (index $methodParams 1).Name $sourceField.Name}}
						{{else}}
							{{$srcExpr = printf "%s.%s" (index $methodParams 1).Name $sourceField.Name}}
						{{end}}
						{{$srcType := $sourceField.Type}}
						{{if or (eq $sourceField.Name $sliceField.Name) (isSlice $sourceField.Type)}}
							{{$srcType = trimPrefix $srcType "[]"}}
						{{end}}
						{{generateFieldConversion $targetStructField.Name $targetStructField.Type $srcType $srcExpr}},
					{{end}}
				{{end}}
				},
			)
			if err != nil {
				{{$retType := firstReturnType .Returns}}
				return {{if .ReturnsSelf}}nil, {{else if not .HasValue}}{{else if isSlice $retType}}nil, {{else if isDomainStruct .ReturnElem}}{{.ReturnElem}}{}, {{else}}{{zeroValue $retType}}, {{end}}err
			}
		}
		return nil
	{{else}}
		{{template "standardBody" (dict "Method" . "Engine" $.Engine "Structs" $.Structs "PackageName" $.PackageName)}}
	{{end}}
}
{{end}}

{{define "standardBody"}}
	{{- $method := .Method -}}
	{{- $methodParams := .Method.Params -}}
	{{- if and .Engine.IsPostgres (gt (len .Method.Params) 1) -}}
		{{- $pType := (index .Method.Params 1).Type -}}
		{{- $sInfo := getStruct $pType -}}
		{{- if and (ne $sInfo.Name "") (hasSliceField $sInfo) -}}
			{{- $sliceField := getSliceField $sInfo -}}
			{{/* Check for mismatched slice lengths */}}
			{{- range $sInfo.Fields -}}
				{{- if and (isSlice .Type) (ne .Name $sliceField.Name) -}}
		if len({{(index $methodParams 1).Name}}.{{.Name}}) != len({{(index $methodParams 1).Name}}.{{$sliceField.Name}}) {
			{{$retType := firstReturnType $method.Returns}}
			return {{if $method.ReturnsSelf}}nil, {{else if not $method.HasValue}}{{else if isSlice $retType}}nil, {{else if isDomainStruct $method.ReturnElem}}{{$method.ReturnElem}}{}, {{else}}{{zeroValue $retType}}, {{end}}ErrMismatchedSlices
		}
				{{- end -}}
			{{- end -}}
		{{- end -}}
	{{- end -}}
	{{if and .Engine.IsMySQL .Method.IsCreate}}
		// MySQL does not support RETURNING for INSERTs.
		// We insert, get LastInsertId, and then fetch the object.
		res, err := w.adapter.{{.Method.Name}}({{joinParamsCall .Method.Params .Engine.Package .Method.Name}})
		if err != nil {
			return {{.Method.ReturnElem}}{}, err
		}

		id, err := res.LastInsertId()
		if err != nil {
			return {{.Method.ReturnElem}}{}, err
		}

		nf, err := w.Get{{.Method.ReturnElem}}ByID(ctx, id)
		if err == nil {
			return nf, nil
		}
		if !errors.Is(err, ErrNotFound) {
			return {{.Method.ReturnElem}}{}, err
		}

		// MySQL REPEATABLE READ: if ON DUPLICATE KEY UPDATE fired (another transaction
		// already committed this row), the current transaction's MVCC snapshot may not
		// see it via GetByID. Fall back to a non-transactional lookup on the raw DB
		// connection, which always reads the latest committed data.
		return (&mysqlWrapper{adapter: {{.Engine.Package}}.NewAdapter(w.adapter.DB())}).Get{{.Method.ReturnElem}}ByID(ctx, id)
	{{else if and .Engine.IsMySQL .Method.IsUpdate}}
		// MySQL does not support RETURNING for UPDATEs.
		// We update, and then fetch the object by its unique key (assumed to be the first param after context, or we try by Hash if it exists).
		res, err := w.adapter.{{.Method.Name}}({{joinParamsCall .Method.Params .Engine.Package .Method.Name}})
		if err != nil {
			return {{.Method.ReturnElem}}{}, err
		}

		rowsAffected, err := res.RowsAffected()
		if err != nil {
			return {{.Method.ReturnElem}}{}, err
		}
		if rowsAffected == 0 {
			return {{.Method.ReturnElem}}{}, ErrNotFound
		}

		{{if hasParam "id" .Method.Params}}
		return w.Get{{.Method.ReturnElem}}ByID(ctx, id)
		{{else if hasParam "hash" .Method.Params}}
		return w.Get{{.Method.ReturnElem}}ByHash(ctx, hash)
		{{else if hasParam "key" .Method.Params}}
		return w.Get{{.Method.ReturnElem}}ByKey(ctx, key)
		{{else if paramHasField "arg" "ID" .Method.Params $.Structs}}
		return w.Get{{.Method.ReturnElem}}ByID(ctx, arg.ID)
		{{else if paramHasField "arg" "Hash" .Method.Params $.Structs}}
		return w.Get{{.Method.ReturnElem}}ByHash(ctx, arg.Hash)
		{{else if paramHasField "arg" "Key" .Method.Params $.Structs}}
		return w.Get{{.Method.ReturnElem}}ByKey(ctx, arg.Key)
		{{else}}
		// Fallback to error if we can't easily fetch it by a common key.
		return {{.Method.ReturnElem}}{}, errors.New("cannot fetch updated object: no common unique key parameter (id, hash, key) found")
		{{end}}

	{{else if .Method.IsSynthetic}}
		{{- $tableName := getTableName .Method.ReturnElem -}}
		{{- $placeholder := "?" -}}
		{{- if .Engine.IsPostgres -}}
			{{- $placeholder = "$1" -}}
		{{- end -}}
		{{$targetStruct := getTargetStruct .Method.ReturnElem}}
		query := "SELECT {{range $i, $f := $targetStruct.Fields}}{{if $i}}, {{end}}{{quote $.Engine (toSnakeCase $f.Name)}}{{end}} FROM {{$tableName}} WHERE id = {{$placeholder}}"
		row := w.adapter.DBTX().QueryRowContext(ctx, query, id)
		var res {{.Engine.Package}}.{{.Method.ReturnElem}}
		err := row.Scan(
			{{range $targetField := $targetStruct.Fields}}
				&res.{{$targetField.Name}},
			{{end}}
		)
		if err != nil {
			if errors.Is(err, sql.ErrNoRows) {
				return {{.Method.ReturnElem}}{}, ErrNotFound
			}
			return {{.Method.ReturnElem}}{}, err
		}

		// Convert to Domain Struct
		{{$domainStruct := getStruct .Method.ReturnElem}}
		return {{.Method.ReturnElem}}{
			{{range $domainField := $domainStruct.Fields}}
				{{$sourceField := dict "Name" ""}}
				{{range $sf := $targetStruct.Fields}}
					{{if eq $sf.Name $domainField.Name}}
						{{$sourceField = $sf}}
					{{end}}
				{{end}}
				{{if ne $sourceField.Name ""}}
					{{generateFieldConversion $domainField.Name $domainField.Type $sourceField.Type (printf "res.%s" $sourceField.Name)}},
				{{end}}
			{{end}}
		}, nil
	{{else}}

	{{/* --- Standard Handling --- */}}
		{{- $retType := firstReturnType .Method.Returns -}}
		{{- $targetMethod := getTargetMethod .Method.Name -}}
		{{- $targetRetType := firstReturnType $targetMethod.Returns -}}

		{{if not .Method.HasValue}}
			{{if .Method.ReturnsError}}
				return w.adapter.{{.Method.Name}}({{joinParamsCall .Method.Params .Engine.Package .Method.Name}})
			{{else}}
				w.adapter.{{.Method.Name}}({{joinParamsCall .Method.Params .Engine.Package .Method.Name}})
				return
			{{end}}
		{{else}}
			res{{if .Method.ReturnsError}}, err{{end}} := w.adapter.{{.Method.Name}}({{joinParamsCall .Method.Params .Engine.Package .Method.Name}})
			{{if .Method.ReturnsError}}
				if err != nil {
					{{if and .Method.HasValue (not (isSlice $retType)) (or (isDomainStruct .Method.ReturnElem) .Method.ReturnsSelf)}}
						if errors.Is(err, sql.ErrNoRows) {
							return {{if .Method.ReturnsSelf}}nil, {{else if isSlice $retType}}nil, {{else if isDomainStruct .Method.ReturnElem}}{{.Method.ReturnElem}}{}, {{else}}{{zeroValue $retType}}, {{end}}ErrNotFound
						}
					{{end}}
					return {{if .Method.ReturnsSelf}}nil, {{else if isSlice $retType}}nil, {{else if isDomainStruct .Method.ReturnElem}}{{.Method.ReturnElem}}{}, {{else}}{{zeroValue $retType}}, {{end}}err
				}
			{{end}}

			{{if .Method.ReturnsSelf}}
				// Wrap the returned adapter (for WithTx)
				return &{{.Engine.Name}}Wrapper{adapter: res}
			{{else if isSlice $retType}}
				{{if isDomainStruct .Method.ReturnElem}}
					// Convert Slice of Domain Structs
					items := make([]{{.Method.ReturnElem}}, len(res))
					for i, v := range res {
						{{$targetStruct := getStruct .Method.ReturnElem}}
						{{$sourceStruct := getTargetStruct .Method.ReturnElem}}
						items[i] = {{.Method.ReturnElem}}{
							{{range $targetField := $targetStruct.Fields}}
								{{$sourceField := dict "Name" ""}}
								{{range $sf := $sourceStruct.Fields}}
									{{if eq $sf.Name $targetField.Name}}
										{{$sourceField = $sf}}
									{{end}}
								{{end}}
								{{if ne $sourceField.Name ""}}
									{{generateFieldConversion $targetField.Name $targetField.Type $sourceField.Type (printf "v.%s" $sourceField.Name)}},
								{{end}}
							{{end}}
						}
					}
					return items{{if .Method.ReturnsError}}, nil{{end}}
				{{else}}
					// Return Slice of Primitives (direct match)
					return res{{if .Method.ReturnsError}}, nil{{end}}
				{{end}}
			{{else if isDomainStruct .Method.ReturnElem}}
				// Convert Single Domain Struct
				{{$targetStruct := getStruct .Method.ReturnElem}}
				{{$sourceStruct := getTargetStruct .Method.ReturnElem}}
				return {{.Method.ReturnElem}}{
					{{range $targetField := $targetStruct.Fields}}
						{{$sourceField := dict "Name" ""}}
						{{range $sf := $sourceStruct.Fields}}
							{{if eq $sf.Name $targetField.Name}}
								{{$sourceField = $sf}}
							{{end}}
						{{end}}
						{{if ne $sourceField.Name ""}}
							{{generateFieldConversion $targetField.Name $targetField.Type $sourceField.Type (printf "res.%s" $sourceField.Name)}},
						{{end}}
					{{end}}
				}{{if .Method.ReturnsError}}, nil{{end}}
			{{else}}
				// Return Primitive / *sql.DB / etc
				{{if and (eq $retType "bool") (eq $targetRetType "int64")}}
					return res != 0{{if .Method.ReturnsError}}, nil{{end}}
				{{else if and (ne $retType $targetRetType) (ne $targetRetType "")}}
					return {{$retType}}(res){{if .Method.ReturnsError}}, nil{{end}}
				{{else}}
					return res{{if .Method.ReturnsError}}, nil{{end}}
				{{end}}
			{{end}}
		{{end}}

	{{end}}
{{end}}

func (w *{{.Engine.Name}}Wrapper) WithTx(tx *sql.Tx) Querier {
	res := w.adapter.WithTx(tx)
	return &{{.Engine.Name}}Wrapper{adapter: res}
}

func (w *{{.Engine.Name}}Wrapper) DB() *sql.DB {
	return w.adapter.DB()
}
`
