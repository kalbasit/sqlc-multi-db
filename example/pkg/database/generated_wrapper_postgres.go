// Code generated by sqlc-multi-db. DO NOT EDIT.
package database

import (
	"context"
	"database/sql"
	"errors"

	"github.com/kalbasit/sqlc-multi-db/example/pkg/database/postgresdb"
)

// postgresWrapper wraps the postgres adapter.
type postgresWrapper struct {
	adapter *postgresdb.Adapter
}

func (w *postgresWrapper) AddBookTag(ctx context.Context, arg AddBookTagParams) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	return w.adapter.AddBookTag(ctx, postgresdb.AddBookTagParams{
		BookID: arg.BookID,
		TagID:  arg.TagID,
	})
}

func (w *postgresWrapper) AddBookTags(ctx context.Context, arg AddBookTagsParams) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	if len(arg.TagID) != len(arg.BookID) {
		return ErrMismatchedSlices
	}

	return w.adapter.AddBookTags(ctx, postgresdb.AddBookTagsParams{
		BookID: arg.BookID,
		TagID:  arg.TagID,
	})
}

func (w *postgresWrapper) CreateBook(ctx context.Context, arg CreateBookParams) (Book, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.CreateBook(ctx, postgresdb.CreateBookParams{
		Title:       arg.Title,
		Author:      arg.Author,
		Description: arg.Description,
	})
	if err != nil {

		if errors.Is(err, sql.ErrNoRows) {
			return Book{}, ErrNotFound
		}

		return Book{}, err
	}

	// Convert Single Domain Struct

	return Book{
		ID: res.ID,

		Title: res.Title,

		Author: res.Author,

		Description: res.Description,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,
	}, nil
}

func (w *postgresWrapper) CreateTag(ctx context.Context, name string) (Tag, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.CreateTag(ctx, name)
	if err != nil {

		if errors.Is(err, sql.ErrNoRows) {
			return Tag{}, ErrNotFound
		}

		return Tag{}, err
	}

	// Convert Single Domain Struct

	return Tag{
		ID: res.ID,

		Name: res.Name,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,
	}, nil
}

func (w *postgresWrapper) DeleteBook(ctx context.Context, id int64) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	return w.adapter.DeleteBook(ctx, id)
}

func (w *postgresWrapper) GetBook(ctx context.Context, id int64) (Book, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetBook(ctx, id)
	if err != nil {

		if errors.Is(err, sql.ErrNoRows) {
			return Book{}, ErrNotFound
		}

		return Book{}, err
	}

	// Convert Single Domain Struct

	return Book{
		ID: res.ID,

		Title: res.Title,

		Author: res.Author,

		Description: res.Description,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,
	}, nil
}

func (w *postgresWrapper) GetBookByID(ctx context.Context, id int64) (Book, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	query := "SELECT \"id\", \"title\", \"author\", \"description\", \"created_at\", \"updated_at\" FROM books WHERE id = $1"
	row := w.adapter.DBTX().QueryRowContext(ctx, query, id)
	var res postgresdb.Book
	err := row.Scan(

		&res.ID,

		&res.Title,

		&res.Author,

		&res.Description,

		&res.CreatedAt,

		&res.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return Book{}, ErrNotFound
		}
		return Book{}, err
	}

	// Convert to Domain Struct

	return Book{
		ID: res.ID,

		Title: res.Title,

		Author: res.Author,

		Description: res.Description,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,
	}, nil
}

func (w *postgresWrapper) GetBookTags(ctx context.Context, bookID int64) ([]Tag, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetBookTags(ctx, bookID)
	if err != nil {
		return nil, err
	}

	// Convert Slice of Domain Structs
	items := make([]Tag, len(res))
	for i, v := range res {
		items[i] = Tag{
			ID: v.ID,

			Name: v.Name,

			CreatedAt: v.CreatedAt,

			UpdatedAt: v.UpdatedAt,
		}
	}
	return items, nil
}

func (w *postgresWrapper) GetBooksByAuthor(ctx context.Context, author string) ([]Book, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetBooksByAuthor(ctx, author)
	if err != nil {
		return nil, err
	}

	// Convert Slice of Domain Structs
	items := make([]Book, len(res))
	for i, v := range res {
		items[i] = Book{
			ID: v.ID,

			Title: v.Title,

			Author: v.Author,

			Description: v.Description,

			CreatedAt: v.CreatedAt,

			UpdatedAt: v.UpdatedAt,
		}
	}
	return items, nil
}

func (w *postgresWrapper) GetTag(ctx context.Context, id int64) (Tag, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetTag(ctx, id)
	if err != nil {

		if errors.Is(err, sql.ErrNoRows) {
			return Tag{}, ErrNotFound
		}

		return Tag{}, err
	}

	// Convert Single Domain Struct

	return Tag{
		ID: res.ID,

		Name: res.Name,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,
	}, nil
}

func (w *postgresWrapper) GetTagByID(ctx context.Context, id int64) (Tag, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	query := "SELECT \"id\", \"name\", \"created_at\", \"updated_at\" FROM tags WHERE id = $1"
	row := w.adapter.DBTX().QueryRowContext(ctx, query, id)
	var res postgresdb.Tag
	err := row.Scan(

		&res.ID,

		&res.Name,

		&res.CreatedAt,

		&res.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return Tag{}, ErrNotFound
		}
		return Tag{}, err
	}

	// Convert to Domain Struct

	return Tag{
		ID: res.ID,

		Name: res.Name,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,
	}, nil
}

func (w *postgresWrapper) ListBooks(ctx context.Context) ([]Book, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.ListBooks(ctx)
	if err != nil {
		return nil, err
	}

	// Convert Slice of Domain Structs
	items := make([]Book, len(res))
	for i, v := range res {
		items[i] = Book{
			ID: v.ID,

			Title: v.Title,

			Author: v.Author,

			Description: v.Description,

			CreatedAt: v.CreatedAt,

			UpdatedAt: v.UpdatedAt,
		}
	}
	return items, nil
}

func (w *postgresWrapper) UpdateBook(ctx context.Context, arg UpdateBookParams) (Book, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.UpdateBook(ctx, postgresdb.UpdateBookParams{
		Title:       arg.Title,
		Author:      arg.Author,
		Description: arg.Description,
		ID:          arg.ID,
	})
	if err != nil {

		if errors.Is(err, sql.ErrNoRows) {
			return Book{}, ErrNotFound
		}

		return Book{}, err
	}

	// Convert Single Domain Struct

	return Book{
		ID: res.ID,

		Title: res.Title,

		Author: res.Author,

		Description: res.Description,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,
	}, nil
}

func (w *postgresWrapper) WithTx(tx *sql.Tx) Querier {
	res := w.adapter.WithTx(tx)
	return &postgresWrapper{adapter: res}
}

func (w *postgresWrapper) DB() *sql.DB {
	return w.adapter.DB()
}
