// Code generated by sqlc-multi-db. DO NOT EDIT.
package database

import (
	"context"
	"database/sql"
	"errors"

	"github.com/kalbasit/sqlc-multi-db/example/pkg/database/mysqldb"
)

// mysqlWrapper wraps the mysql adapter.
type mysqlWrapper struct {
	adapter *mysqldb.Adapter
}

func (w *mysqlWrapper) AddBookTag(ctx context.Context, arg AddBookTagParams) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	return w.adapter.AddBookTag(ctx, mysqldb.AddBookTagParams{
		BookID: arg.BookID,
		TagID:  arg.TagID,
	})
}

func (w *mysqlWrapper) AddBookTags(ctx context.Context, arg AddBookTagsParams) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	if len(arg.TagID) != len(arg.BookID) {
		return ErrMismatchedSlices
	}
	for i, v := range arg.BookID {
		_ = i
		err := w.adapter.AddBookTag(ctx, mysqldb.AddBookTagParams{
			BookID: v,

			TagID: arg.TagID[i],
		},
		)
		if err != nil {
			return err
		}
	}
	return nil
}

func (w *mysqlWrapper) CreateBook(ctx context.Context, arg CreateBookParams) (Book, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	// MySQL does not support RETURNING for INSERTs.
	// We insert, get LastInsertId, and then fetch the object.
	res, err := w.adapter.CreateBook(ctx, mysqldb.CreateBookParams{
		Title:       arg.Title,
		Author:      arg.Author,
		Description: arg.Description,
	})
	if err != nil {
		return Book{}, err
	}

	id, err := res.LastInsertId()
	if err != nil {
		return Book{}, err
	}

	nf, err := w.GetBookByID(ctx, id)
	if err == nil {
		return nf, nil
	}
	if !errors.Is(err, ErrNotFound) {
		return Book{}, err
	}

	// MySQL REPEATABLE READ: if ON DUPLICATE KEY UPDATE fired (another transaction
	// already committed this row), the current transaction's MVCC snapshot may not
	// see it via GetByID. Fall back to a non-transactional lookup on the raw DB
	// connection, which always reads the latest committed data.
	return (&mysqlWrapper{adapter: mysqldb.NewAdapter(w.adapter.DB())}).GetBookByID(ctx, id)
}

func (w *mysqlWrapper) CreateTag(ctx context.Context, name string) (Tag, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	// MySQL does not support RETURNING for INSERTs.
	// We insert, get LastInsertId, and then fetch the object.
	res, err := w.adapter.CreateTag(ctx, name)
	if err != nil {
		return Tag{}, err
	}

	id, err := res.LastInsertId()
	if err != nil {
		return Tag{}, err
	}

	nf, err := w.GetTagByID(ctx, id)
	if err == nil {
		return nf, nil
	}
	if !errors.Is(err, ErrNotFound) {
		return Tag{}, err
	}

	// MySQL REPEATABLE READ: if ON DUPLICATE KEY UPDATE fired (another transaction
	// already committed this row), the current transaction's MVCC snapshot may not
	// see it via GetByID. Fall back to a non-transactional lookup on the raw DB
	// connection, which always reads the latest committed data.
	return (&mysqlWrapper{adapter: mysqldb.NewAdapter(w.adapter.DB())}).GetTagByID(ctx, id)
}

func (w *mysqlWrapper) DeleteBook(ctx context.Context, id int64) error {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	return w.adapter.DeleteBook(ctx, id)
}

func (w *mysqlWrapper) GetBook(ctx context.Context, id int64) (Book, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetBook(ctx, id)
	if err != nil {

		if errors.Is(err, sql.ErrNoRows) {
			return Book{}, ErrNotFound
		}

		return Book{}, err
	}

	// Convert Single Domain Struct

	return Book{
		ID: res.ID,

		Title: res.Title,

		Author: res.Author,

		Description: res.Description,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,
	}, nil
}

func (w *mysqlWrapper) GetBookByID(ctx context.Context, id int64) (Book, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	query := "SELECT `id`, `title`, `author`, `description`, `created_at`, `updated_at` FROM books WHERE id = ?"
	row := w.adapter.DBTX().QueryRowContext(ctx, query, id)
	var res mysqldb.Book
	err := row.Scan(

		&res.ID,

		&res.Title,

		&res.Author,

		&res.Description,

		&res.CreatedAt,

		&res.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return Book{}, ErrNotFound
		}
		return Book{}, err
	}

	// Convert to Domain Struct

	return Book{
		ID: res.ID,

		Title: res.Title,

		Author: res.Author,

		Description: res.Description,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,
	}, nil
}

func (w *mysqlWrapper) GetBookTags(ctx context.Context, bookID int64) ([]Tag, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetBookTags(ctx, bookID)
	if err != nil {
		return nil, err
	}

	// Convert Slice of Domain Structs
	items := make([]Tag, len(res))
	for i, v := range res {
		items[i] = Tag{
			ID: v.ID,

			Name: v.Name,

			CreatedAt: v.CreatedAt,

			UpdatedAt: v.UpdatedAt,
		}
	}
	return items, nil
}

func (w *mysqlWrapper) GetBooksByAuthor(ctx context.Context, author string) ([]Book, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetBooksByAuthor(ctx, author)
	if err != nil {
		return nil, err
	}

	// Convert Slice of Domain Structs
	items := make([]Book, len(res))
	for i, v := range res {
		items[i] = Book{
			ID: v.ID,

			Title: v.Title,

			Author: v.Author,

			Description: v.Description,

			CreatedAt: v.CreatedAt,

			UpdatedAt: v.UpdatedAt,
		}
	}
	return items, nil
}

func (w *mysqlWrapper) GetTag(ctx context.Context, id int64) (Tag, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.GetTag(ctx, id)
	if err != nil {

		if errors.Is(err, sql.ErrNoRows) {
			return Tag{}, ErrNotFound
		}

		return Tag{}, err
	}

	// Convert Single Domain Struct

	return Tag{
		ID: res.ID,

		Name: res.Name,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,
	}, nil
}

func (w *mysqlWrapper) GetTagByID(ctx context.Context, id int64) (Tag, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	query := "SELECT `id`, `name`, `created_at`, `updated_at` FROM tags WHERE id = ?"
	row := w.adapter.DBTX().QueryRowContext(ctx, query, id)
	var res mysqldb.Tag
	err := row.Scan(

		&res.ID,

		&res.Name,

		&res.CreatedAt,

		&res.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return Tag{}, ErrNotFound
		}
		return Tag{}, err
	}

	// Convert to Domain Struct

	return Tag{
		ID: res.ID,

		Name: res.Name,

		CreatedAt: res.CreatedAt,

		UpdatedAt: res.UpdatedAt,
	}, nil
}

func (w *mysqlWrapper) ListBooks(ctx context.Context) ([]Book, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	res, err := w.adapter.ListBooks(ctx)
	if err != nil {
		return nil, err
	}

	// Convert Slice of Domain Structs
	items := make([]Book, len(res))
	for i, v := range res {
		items[i] = Book{
			ID: v.ID,

			Title: v.Title,

			Author: v.Author,

			Description: v.Description,

			CreatedAt: v.CreatedAt,

			UpdatedAt: v.UpdatedAt,
		}
	}
	return items, nil
}

func (w *mysqlWrapper) UpdateBook(ctx context.Context, arg UpdateBookParams) (Book, error) {
	/* --- Auto-Loop for Bulk Insert on Non-Postgres --- */

	// MySQL does not support RETURNING for UPDATEs.
	// We update, and then fetch the object by its unique key (assumed to be the first param after context, or we try by Hash if it exists).
	res, err := w.adapter.UpdateBook(ctx, mysqldb.UpdateBookParams{
		Title:       arg.Title,
		Author:      arg.Author,
		Description: arg.Description,
		ID:          arg.ID,
	})
	if err != nil {
		return Book{}, err
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return Book{}, err
	}
	if rowsAffected == 0 {
		return Book{}, ErrNotFound
	}

	return w.GetBookByID(ctx, arg.ID)
}

func (w *mysqlWrapper) WithTx(tx *sql.Tx) Querier {
	res := w.adapter.WithTx(tx)
	return &mysqlWrapper{adapter: res}
}

func (w *mysqlWrapper) DB() *sql.DB {
	return w.adapter.DB()
}
